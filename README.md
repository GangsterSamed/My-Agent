# Browser Agent (MCP)

Автономный AI‑агент, управляющий веб‑браузером через **MCP (Model Context Protocol)**. Принимает текстовые задачи, сам решает шаги (навигация, клики, ввод, скролл) и выполняет их в видимом браузере.

---

## Возможности

- **Программное управление браузером** — Playwright, инструменты доступны агенту через MCP.
- **Видимый браузер** — по умолчанию не headless; можно переключить в headless через `AGENT_HEADLESS=true`.
- **Сохранение сессий** — состояние браузера (логины, cookies) сохраняется в `browser_state.json` при выходе. Один раз вводишь логин/пароль вручную в браузере (или через задачу), при следующих запусках сессия подхватывается, повторно вводить не нужно.
- **Автономная работа** — LLM (Claude/OpenAI‑совместимый API) сам планирует шаги, вызывает MCP‑инструменты, обрабатывает ошибки и переходит между страницами.
- **Управление контекстом** — в LLM уходит выжимка страницы (текст, кнопки, ссылки, поля), а не полный HTML, чтобы уложиться в лимиты по токенам.
- **Обработка ошибок** — при неудачном действии агент пробует другой способ (другой текст, scroll, другой элемент). Если одно и то же действие 3 раза подряд завершилось ошибкой, управление передаётся пользователю — он выполняет шаг вручную в браузере и пишет «готово».
- **Security layer** — перед опасными действиями (оплата, удаление навсегда и т.п.) запрашивается подтверждение в терминале.

---

## Архитектура

```
┌─────────────────────────────────────────────────────────────────┐
│  main.py → agent.py (MCP‑клиент + LLM‑цикл)                      │
│  • Читает задачу из терминала                                    │
│  • Отправляет в LLM (OpenAI‑совместимый API)                     │
│  • Вызывает MCP tools через ClientSession                        │
│  • Итог + время выполнения в конце задачи                        │
└────────────────────────────┬────────────────────────────────────┘
                             │ stdio (StdioServerParameters)
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│  mcp_server.py (MCP‑сервер, подпроцесс)                          │
│  • Playwright: Chromium (видимый или headless)                   │
│  • Tools: navigate, get_page_content, click_element,             │
│           type_text, scroll, go_back, extract_elements           │
│  • Load/save storage_state (browser_state.json по умолчанию)     │
└─────────────────────────────────────────────────────────────────┘
```

Агент запускает MCP‑сервер как подпроцесс, подключается через stdio, получает список инструментов (`list_tools`) и в цикле вызывает их (`call_tool`) по решению LLM.

---

## Требования

- **Python 3.10+**
- Доступ к **OpenAI‑совместимому API** (OpenAI, Hydra, и т.п.) — нужны `OPENAI_API_KEY` и при использовании прокси `OPENAI_BASE_URL`.

---

## Установка

Используй **venv в каталоге `agent-tz`** и **mcp>=1.24.0** — иначе возможны ошибки (например `ListToolsResult` / `validate_input`).

### 1. Перейди в каталог

```bash
cd agent-tz
```

### 2. Создай venv и поставь зависимости

```bash
python3 -m venv .venv
source .venv/bin/activate   # Linux/macOS
# .venv\Scripts\activate    # Windows

pip install -r requirements.txt
playwright install chromium
```

### 3. Настрой окружение

Создай файл `.env` в каталоге `agent-tz` и добавь переменные (пример ниже):

```env
# Обязательно
OPENAI_API_KEY=your-api-key
OPENAI_BASE_URL=https://api.hydraai.ru/v1/
OPENAI_MODEL=claude-sonnet-4-20250514

# Браузер: false = видимый, true = headless
AGENT_HEADLESS=false

# Сессия: путь к JSON (по умолчанию browser_state.json)
# AGENT_STORAGE_STATE=browser_state.json

# Тихий режим: не печатать в stderr «Сессия загружена», «Браузер запущен» и т.п. (по умолчанию true)
# AGENT_QUIET=true

# Размер окна браузера (не headless): ШиринаxВысота, по умолчанию 1100x700
# AGENT_WINDOW_SIZE=1100x700

# Передача управления: true = при 3 ошибках подряд просить выполнить вручную (по умолчанию), 0 = отключить
# AGENT_HANDOVER_AFTER_RETRIES=true
```

- **`OPENAI_API_KEY`** — ключ API (обязательно).
- **`OPENAI_BASE_URL`** — базовый URL провайдера (для Hydra: `https://api.hydraai.ru/v1/`). Если используешь OpenAI напрямую, можно не задавать.
- **`OPENAI_MODEL`** — модель (например `claude-sonnet-4-20250514` или `gpt-4o`). Можно задать **`ANTHROPIC_MODEL`**, если используется вместо `OPENAI_MODEL`.
- **`AGENT_HEADLESS`** — `false` (видимый браузер) или `true` (headless).
- **`AGENT_STORAGE_STATE`** — путь к файлу сессии (логины, cookies). По умолчанию `browser_state.json` в каталоге `agent-tz`. При выходе сессия сохраняется; при следующем запуске подхватывается — логин/пароль вводить заново не нужно.
- **`AGENT_QUIET`** — `true` (по умолчанию): не выводить в stderr сообщения «Сессия загружена», «Браузер запущен», «Сессия сохранена при выходе». Поставь `false`, если нужны эти логи.
- **`AGENT_WINDOW_SIZE`** — размер окна браузера в не-headless (`ШиринаxВысота`). По умолчанию `1100x700` (~половина экрана). Пример: `1280x800`.

**Отладка и таймауты:**

- **`AGENT_DEBUG_LLM=1`** — перед каждым запросом к LLM выводить шаг, число сообщений, размер, роли, факт нормализации Hydra+Claude. Последний запрос сохраняется в `agent_debug_last_request.json`.
- **`AGENT_DIAG=1`** — выводить в stderr маркеры MCP-сервера (клики, fallback'и, type_text по field_index). Полезно, чтобы по логам понять, какие ветки кода сработали.
- **`AGENT_SKIP_HYDRA_NORMALIZE=1`** — отключить нормализацию сообщений для Claude через HydraAI (если из‑за неё таймауты или ошибки).
- **`AGENT_LLM_TIMEOUT_SEC`** — таймаут запроса к LLM в секундах (по умолчанию 90). При медленном API можно увеличить (например `120` или `180`).
- **`AGENT_HANDOVER_AFTER_RETRIES=0`** — отключить передачу управления после 3 неудачных попыток. По умолчанию `true`: при 3 ошибках подряд агент просит выполнить шаг вручную; при `0`/`false` возвращается ошибка без handover.

**Маркеры в логах (по ним видно, применились ли изменения в коде):**

| Что искать в логе | Значение |
|-------------------|----------|
| `[DIAG] get_page_content time_since_nav=...` | Вызов get_page_content с таймингами |
| `[DIAG] click_element start text=...` | Начало клика по элементу |
| `[DIAG] click_element text normalized` | В тексте были \xa0, \u2009, переносы — применена нормализация |
| `[DIAG] click_element: text not in dialog -> return error suggest=...` | Текст не в кнопках диалога — возврат ошибки с подсказкой |
| `[DIAG] click_element effective_scope=page/dialog use_text=...` | Выбран scope (страница или диалог) |
| `[DIAG] dialog_diag (scope=dialog) hasDialog=... btnTexts=... primaryBtn=...` | Диалог и кнопки в нём |
| `[DIAG] click_element dialog DISABLED btn=... reason=...` | Кнопка недоступна (нужно выбрать опцию) |
| `[DIAG] click_element dialog FAILED search=... dialog_btnTexts=...` | Элемент не найден в диалоге |
| `[DIAG] click_element: close-modal fallback -> Escape` | Закрытие модалки через Escape |
| `[DIAG] click_element dialog Playwright fallback err=...` | Ошибка Playwright-клика в диалоге |
| `[DIAG] click_element AMBIGUOUS request=... count=... contexts=...` | Неоднозначный запрос — много совпадений |
| `[DIAG] click_element JS debug searchParts=... sample=...` | JS не нашёл элемент — отладка |
| `[DIAG] click_element fallback chose by text matched=...` | Fallback: выбор по тексту |
| `[DIAG] click_element page done matched=... clickedContext=...` | Клик по странице — элемент найден |
| `[DIAG] click_element timeout, retrying with force=True` | Таймаут — повтор с force |
| `[click] force=True succeeded` | force retry прошёл успешно |
| `[DIAG] click_element EXCEPTION err=...` | Исключение при клике |
| `[DIAG] filter_off_screen filtered_buttons=N filtered_links=M` | Исключены N кнопок и M ссылок вне viewport |
| `[DIAG] scroll target=dialog/window` / `[DIAG] scroll container=...` | Прокрутка модалки, окна или контейнера |
| `[DIAG] step N tool N/M: ... elapsed=...` | Шаг агента, инструмент, время |
| `[DIAG] page_navigated: skipping tool N/M (name)` | После навигации пропущены оставшиеся инструменты |

---

## Запуск

**Вариант A — через скрипт (всегда использует venv):**

```bash
./run.sh
```

**Вариант B — вручную (сначала активируй venv):**

```bash
source .venv/bin/activate
python3 main.py
```

В терминале появится приглашение ввести задачу. Вводи задачу текстом и нажимай Enter. После выполнения можно ввести следующую — агент работает в цикле. Для выхода введи `quit`, `exit`, `q` или `выход`. В конце каждой задачи выводится краткий **итог** (что сделано) и **время выполнения** (минуты/секунды). Лимит: до 50 шагов LLM на одну задачу.

**Примеры задач:**

- Перейди на https://example.com и скажи заголовок страницы.
- Открой Google, введи в поиск «Python MCP» и опиши первые два результата.
- Перейди на https://httpbin.org/forms/post, заполни форму и покажи, что получилось (без реальной отправки, если не требуется).

Перед деструктивными действиями (оплата, удаление навсегда и т.п.) агент спросит подтверждение в терминале (`y`/`n`).

### Логин и капча

Если агент видит форму входа (логин/пароль) или капчу, он вызывает `wait_for_user` и **ждёт** тебя:

1. В терминале появится: «Войдите в аккаунт или решите капчу в браузере. Напишите «готово» или «done» когда закончите.»
2. Ты входишь или решаешь капчу в **видимом** браузере.
3. Вводишь **готово** или **done** (или ok / продолжай / go) и нажимаешь Enter.
4. Агент продолжает задачу (проверяет страницу и идёт дальше).

### Передача управления (после 3 ошибок)

Если одно и то же действие (например, клик по кнопке) 3 раза подряд завершилось ошибкой, агент останавливается и просит выполнить шаг вручную:

1. В терминале: «Действие не удалось после 3 попыток. Управление передаётся вам.»
2. Выполни шаг в **видимом** браузере (кликни, заполни поле и т.п.).
3. Введи **готово** или **done** и нажми Enter.
4. Агент продолжит задачу (get_page_content и дальше).

Отключить: `AGENT_HANDOVER_AFTER_RETRIES=0` в `.env`.

### Сохранение сессий (логин один раз)

1. Запусти агент, дай задачу с сайтом, где нужен логин.
2. Войди вручную в **видимом** браузере (логин/пароль) или дождись `wait_for_user`, войди, напиши «готово».
3. Выйди через `quit` — сессия сохранится в `browser_state.json`.
4. При следующем запуске сессия подхватится, логин/пароль вводить снова не нужно.

---

## MCP‑инструменты

| Инструмент | Описание |
|------------|----------|
| `navigate` | Перейти по URL. |
| `get_page_content` | Получить выжимку страницы: текст, кнопки, ссылки, поля ввода. |
| `click_element` | Клик по элементу: по видимому тексту или CSS‑селектору. |
| `type_text` | Ввести текст в поле (по placeholder, селектору или первому подходящему полю). |
| `scroll` | Скролл вверх/вниз на заданное количество пикселей. |
| `go_back` | Вернуться на предыдущую страницу (кнопка «Назад»). |
| `extract_elements` | Извлечь элементы по типу: `links`, `buttons`, `inputs`, `headings`. |
| `wait_for_user` | Остановиться и ждать: пользователь входит в аккаунт или решает капчу в браузере, пишет «готово»/«done», агент продолжает. |
| `finish_task` | Завершить задачу. Вызов с `summary` (краткий итог) — агент останавливается и выводит итог пользователю. |

Селекторы и подсказки по страницам не захардкожены — агент сам определяет, куда кликать и что вводить, по результатам `get_page_content` и др.

---

## Структура проекта

```
agent-tz/
├── run.sh            # Запуск из venv: ./run.sh
├── main.py           # Точка входа: python3 main.py
├── agent.py          # MCP‑клиент, цикл LLM + tool calls, ввод задач, UI
├── mcp_server.py     # MCP‑сервер: Playwright, инструменты браузера
├── requirements.txt  # Зависимости Python
├── .venv/            # venv проекта (mcp>=1.24, playwright и т.д.)
├── .env              # Конфигурация (создаётся вручную, не коммитится)
├── .gitignore        # Игнор .env, browser_state.json, .venv и т.д.
├── browser_state.json # Сессия (логины, cookies); создаётся при сохранении
└── README.md
```

---

## Устранение неполадок

### `OPENAI_API_KEY не задан`

Создай `.env` в каталоге `agent-tz` и задай `OPENAI_API_KEY`. Запускай `agent.py` из этого каталога (или укажи путь к `.env` через `python-dotenv`).

### Ошибка 402 от API

Обычно означает «Payment required» / нулевой баланс у провайдера (Hydra и т.п.). Пополни баланс или смени API‑ключ.

### `command not found: pip` / `python`

Используй `python3` и `pip3` (или активируй venv и вызывай `python` / `pip` из него). Запуск агента и установка зависимостей должны идти из **одного и того же** окружения.

### MCP‑сервер не запускается / ошибки импорта

Убедись, что установлены `mcp>=1.24.0`, `playwright`, `anyio` и что `playwright install chromium` выполнен. Запускай из каталога `agent-tz`, чтобы подпроцесс находил `mcp_server.py`.

### Браузер не виден

Проверь `AGENT_HEADLESS=false` в `.env`. Перезапусти агента после изменения `.env`.

### Сессия не сохраняется / при каждом запуске просит логин

По умолчанию сессия пишется в `browser_state.json` в каталоге `agent-tz`. Убедись, что запускаешь агент из этого каталога (так задаётся рабочая директория для MCP‑сервера). Сессия сохраняется только при выходе (`quit`); при `AGENT_QUIET=false` в stderr будет «Сессия сохранена при выходе: ...». Если нужен другой путь — задай `AGENT_STORAGE_STATE` в `.env`.

